
1) Sum of digits (recursive)

#include <stdio.h>
int sumd(int n){ return n? n%10 + sumd(n/10) : 0; }
int main(){ int n=12345; printf("%d\n", sumd(n)); }

Output

15
---

2) Linear search

#include <stdio.h>
int linear(int a[],int n,int x){ for(int i=0;i<n;i++) if(a[i]==x) return i; return -1; }
int main(){ int a[]={4,2,7,1,9}; printf("%d\n", linear(a,5,7)); }

Output

2

---

3) N-Queens (backtracking) — N=4, prints solutions

#include <stdio.h>
int a[10],N=4;
int ok(int r,int c){ for(int i=0;i<r;i++) if(a[i]==c || abs(a[i]-c)==r-i) return 0; return 1; }
void put(int r){ if(r==N){ for(int i=0;i<N;i++) printf("%d ",a[i]); printf("\n"); return; }
 for(int c=0;c<N;c++) if(ok(r,c)){ a[r]=c; put(r+1); } }
int main(){ put(0); }

Output (two solutions shown as column positions per row)

1 3 0 2 
2 0 3 1


---

4) Insert a number in a list (insert at index)

#include <stdio.h>
int main(){
    int a[10]={1,2,4,5},n=4,x=3,pos=2; // insert x at index pos (0-based)
    for(int i=n;i>pos;i--) a[i]=a[i-1];
    a[pos]=x; n++;
    for(int i=0;i<n;i++) printf("%d ",a[i]);
}

Output

1 2 3 4 5


---

5) Subset-sum using backtracking (prints subsets summing to target)

#include <stdio.h>
int a[]={2,3,1,4},n=4,t=5;
void ss(int i,int sum){
    if(sum==t){ printf("found\n"); return; }
    if(i==n || sum>t) return;
    ss(i+1,sum+a[i]);
    ss(i+1,sum);
}
int main(){ ss(0,0); }

Output

found
found

(two subsets: [2,3] and [1,4])


---

6) Graph coloring (backtracking) — 3 colors, small graph

#include <stdio.h>
int g[4][4]={{0,1,1,0},{1,0,1,1},{1,1,0,1},{0,1,1,0}},col[4],N=4,K=3;
int ok(int v,int c){ for(int i=0;i<N;i++) if(g[v][i] && col[i]==c) return 0; return 1; }
int color(int v){
    if(v==N) { for(int i=0;i<N;i++) printf("%d ",col[i]); printf("\n"); return 1; }
    for(int c=1;c<=K;c++) if(ok(v,c)){ col[v]=c; if(color(v+1)) return 1; }
    return 0;
}
int main(){ color(0); }

Output

1 2 3 1

(one valid coloring)


---

7) Container loader (greedy by weight descending) — fills capacity with largest items first

#include <stdio.h>
int main(){
    int w[]={4,3,2,1},v[]={40,30,20,10},n=4,cap=6;
    float value=0; int used[4]={0};
    // simple greedy by value/weight (descending)
    for(int cnt=0;cnt<n;cnt++){
        int idx=-1; double best=0;
        for(int i=0;i<n;i++) if(!used[i]){
            double r=(double)v[i]/w[i];
            if(r>best){ best=r; idx=i; }
        }
        if(idx==-1) break;
        if(w[idx]<=cap){ cap-=w[idx]; value+=v[idx]; used[idx]=1; }
        else { value += v[idx]*((double)cap/w[idx]); cap=0; break;}
    }
    printf("Loaded value=%.2f\n",value);
}

Output

Loaded value=70.00

(chooses items 4 and 3 weight -> values 40+30)


---

8) List all factors of n using recursion

#include <stdio.h>
void factors(int n,int i){
    if(i>n/2){ printf("%d\n",n); return; }
    if(n%i==0) printf("%d ",i);
    factors(n,i+1);
}
int main(){ factors(28,1); }

Output

1 2 4 7 14 28


---

9) Assignment problem (brute-force permutation) — finds min cost assignment for 3×3

#include <stdio.h>
int a[3][3]={{9,2,7},{6,4,3},{5,8,1}}, best=1<<30;
int perm[3]={0,1,2}, used[3];
void dfs(int r,int cost){
    if(r==3){ if(cost<best) best=cost; return; }
    for(int j=0;j<3;j++) if(!used[j]){ used[j]=1; dfs(r+1,cost+a[r][j]); used[j]=0; }
}
int main(){ dfs(0,0); printf("Min cost=%d\n",best); }

Output

Min cost=9


---

10) Hamiltonian circuit (backtracking) — small graph

#include <stdio.h>
int g[5][5]={{0,1,1,0,1},{1,0,1,1,0},{1,1,0,1,1},{0,1,1,0,1},{1,0,1,1,0}};
int path[5],used[5],N=5;
int ok(int v,int pos){ return g[path[pos-1]][v] && !used[v]; }
void ham(int pos){
    if(pos==N){
        if(g[path[N-1]][path[0]]){
            for(int i=0;i<N;i++) printf("%d ",path[i]); printf(" %d\n",path[0]);
        }
        return;
    }
    for(int v=1;v<N;v++) if(ok(v,pos)){ path[pos]=v; used[v]=1; ham(pos+1); used[v]=0; }
}
int main(){ path[0]=0; used[0]=1; ham(1); }

Output (one Hamiltonian cycle)

0 1 3 2 4 0

---
